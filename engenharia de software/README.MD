# Atividade 1

>no primeiro trecho começamos com o questionamento do que seria de fato a engenharia de software e o que distingue ela da ciência da computação. O termo engenharia soa como algo sério e carrega consigo a ideia de construir algo tangivel, o que distoa da engenharia de software que constroi coisas não tão concretas assim, além disso pelo fato de não ser uma profissão regulamentada ela acaba não seguindo regras tão rigorosas, diferentes das outras engenharias onde normalmente as diretrizes são mais rigidas pois erros nos calculos podem causar grandes danos, é importante destacar também que os cursos na área de tecnologia como a engenharia já citada, ciência da computação e outros possuem diversas áreas de atuação e precisam de costantes atualizações pois as coisas nesse ramo costumam ficar obsoletas mais rápido do que em outros, por fim a maior diferença entre as duas está no fato de que enquanto um progrador foca em escrever um código funcional com base em requisitos específicos, o engenheiro de software projeta, desenvolve e o mais importante, mantem aquele sistema funcional e otmizado.

 # Atividade 2

>no segundo trecho do livro é discutido mais a fundo o tópico já citado anteriormente com algumas reflexões como: o que fazer para perpetuar um código por mais tempo, como torna-lo mais sustentável? é necessário que tanto a organização como os engenheiros tenham isso em mente para construir algo que seja adptavel as mudanças, com um custo baixo e que tradeoffs precisarão ser realizadas

 # Atividade 3
 ## exemplos de tradeoffs

1°  custo x tempo - um código mais detalhado demora mais tempo e é mais caro, pórem prolonga sua vida últil e facilita para outros devs

2° funcionalidade x simplicidade -  adicionar muitas funcionalidades pode deixar o sistema confuso e mais dificil de manter pórem um design simples pode não ter os recursos necessários para alguns usuários

3° portabilidade x desempenho - usar linguagens de alto nível torna mais fácil a construção do código pórem se perde o desempenho que as linguagens de baixo nível possuem
